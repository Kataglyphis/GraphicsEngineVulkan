#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "raycommon.glsl"
#include "SetsAndBindings.glsl"

layout(location = 0) rayPayloadEXT HitPayload payload;

layout(set = 0, binding = TLAS_BINDING) uniform accelerationStructureEXT TLAS;
layout(set = 0, binding = OUT_IMAGE_BINDING, rgba32f) uniform image2D image;

layout (set = 0, binding = UBO_VIEW_PROJECTION_BINDING) uniform UboViewProjection {
	
	mat4 projection;
	mat4 view;

} ubo_view_projection;

layout (set = 0, binding = UBO_DIRECTIONS_BINDING) uniform UboDirections {

	vec3 light_dir;
	vec3 view_dir; 

} ubo_directions;

layout(push_constant) uniform PushConstantRay {

    vec4 clear_color;

} pc_ray;

void main() {

    const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 pixel_center_UV = pixel_center / vec2(gl_LaunchSizeEXT.xy);
    vec2 pixel_center_cs = pixel_center_UV * 2.0f - 1.0f;

    // vec4(0,0,0,1) in homogenous coordinates hints that it is the position in the origin
    // assumption: origin is the standpoint from the viewer
    // the inverse gets us the actual world space position
    vec4 origin = inverse(ubo_view_projection.view) * vec4(0, 0, 0, 1);
    vec4 target = inverse(ubo_view_projection.view) * vec4(pixel_center_cs.x, pixel_center_cs.y, 1, 1);
    vec4 direction = inverse(ubo_view_projection.view) * vec4(normalize(target.xyz), 0);

    uint ray_flags = gl_RayFlagsOpaqueEXT;
    float t_min = 0.001;
    float t_max = 10000;

    traceRayExt(TLAS,
                        ray_flags, 
                        0xFF, // cull mask 
                        0,       // sbt record offset 
                        0,      //record stride
                        0,      // miss index
                        origin,
                        t_min,
                        direction,
                        t_max,
                        0);         // payload (location = 0)


    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(payload.hit_value, 1.0));

}